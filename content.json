{"posts":[{"title":"Creating a Custom TabBar with Dynamic Styling in QML","text":"This is a demo showing how to customize tab bar and tab button on QML and Qt 6. You can find the full project here. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import QtQuickimport QtQuick.Controls.Universalimport QtQuick.LayoutsWindow { width: 880 height: 620 visible: true title: qsTr(&quot;Custom TabBar&quot;) ColumnLayout{ anchors.fill: parent spacing: 10 anchors.margins: 20 TabBar { id: tabBar Layout.alignment: Qt.AlignHCenter Layout.preferredWidth: 250 background: Rectangle { color: &quot;lightgray&quot; radius: 10 } TabButton { id: noteTab text: qsTr(&quot;Notes&quot;) implicitHeight: 30 contentItem: Text { text: parent.text horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter color: parent.checked ? &quot;black&quot; : &quot;white&quot; font.bold: true font.pointSize: 14 font.family: &quot;Roboto&quot; padding: 0 } background: Rectangle { color: noteTab.checked ? &quot;white&quot; : &quot;lightgray&quot; border.color: noteTab.checked ? &quot;green&quot; : &quot;lightgray&quot; border.width: 2 radius: 10 } } TabButton { id: archiveTab text: qsTr(&quot;Archive&quot;) implicitHeight: 30 contentItem: Text { text: parent.text horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter color: parent.checked ? &quot;black&quot; : &quot;white&quot; font.bold: true font.pointSize: 14 font.family: &quot;Roboto&quot; } background: Rectangle { color: archiveTab.checked ? &quot;white&quot; : &quot;lightgray&quot; border.color: archiveTab.checked ? &quot;green&quot; : &quot;lightgray&quot; border.width: 2 radius: 10 } } TabButton { id: deletedTab text: qsTr(&quot;Deleted&quot;) implicitHeight: 30 contentItem: Text { text: parent.text horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter color: parent.checked ? &quot;black&quot; : &quot;white&quot; font.bold: true font.pointSize: 14 font.family: &quot;Roboto&quot; } background: Rectangle { color: deletedTab.checked ? &quot;white&quot; : &quot;lightgray&quot; border.color: deletedTab.checked ? &quot;green&quot; : &quot;lightgray&quot; border.width: 2 radius: 10 } } } StackLayout { width: parent.width currentIndex: tabBar.currentIndex Item { id: homeTab Text { text: qsTr(&quot;Notes&quot;) } } Item { id: discoverTab Text { text: qsTr(&quot;Archive&quot;) } } Item { id: trashTab Text { text: qsTr(&quot;Deleted&quot;) } } } }}","link":"/kelvin-blog/2024/12/16/Creating-a-Custom-TabBar-with-Dynamic-Styling-in-QML/"},{"title":"Creating a Multi-Page QML Application with StackView and Dynamic Titles","text":"This tutorial gives you some perspective about how to use StackView to navigate between pages with dynamic titles. You can find the complete project here. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import QtQuickimport QtQuick.ControlsApplicationWindow { //title: currentItem.title width: 640 height: 480 visible: true StackView { id: stackView initialItem: mainPage anchors.fill: parent onCurrentItemChanged: { title = currentItem.title; } } Component { id: mainPage Page { title: qsTr(&quot;Main Page&quot;) Column { Button { text: &quot;Push Page 1&quot; onClicked: stackView.push(page1) } Button { text: &quot;Push Page 2&quot; onClicked: stackView.push(page2) } } } } Component { id: page1 Page { title: &quot;Page 1&quot; Button { text: &quot;Pop&quot; onClicked: stackView.pop() } } } Component { id: page2 Page { title: qsTr(&quot;Page 2&quot;) Button { text: &quot;Pop&quot; onClicked: stackView.pop() } } }}","link":"/kelvin-blog/2024/12/10/Creating-a-Multi-Page-QML-Application-with-StackView-and-Dynamic-Titles-1/"},{"title":"TCP Socket Communication using C++, Qt 6 and QML","text":"In this post we are going to see how to build a TCP socket communication. This idea came to me from the example of Qt 6 C++ GUI Programming Cookbook book. You can find this demo on chapter 7 “Using Network and Managing Large Documents”. In this chapter the client UI is built using Widgets but in this demo we are going to use QML. We will use the TCP server from the book for this demo and we will only build the TCP client. TCP ServerYou can find the TCP server implementation in this link. Furthermore, you will find the TCP client implementation and FTP implementation (which we aren’t going to discuss in this article). TCP ClientIn this repository you will find my TCP client implementation using C++ and QML.This is the header file of TCP client implementation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#ifndef CLIENTCONNECTION_H#define CLIENTCONNECTION_H#include &lt;QObject&gt;#include &lt;QQmlEngine&gt;#include &lt;QString&gt;#include &lt;QDebug&gt;#include &lt;QTcpSocket&gt;class ClientConnection : public QObject{ Q_OBJECT QML_ELEMENT Q_PROPERTY(QString userName READ userName WRITE setUserName NOTIFY userNameChanged) Q_PROPERTY(QString messages READ messages WRITE setMessages NOTIFY messagesChanged) Q_PROPERTY(QString message READ message WRITE setMessage NOTIFY messageChanged) Q_PROPERTY(bool isConnected READ isConnectedToHost NOTIFY isConnectedChanged) QString m_userName; QString m_messages; QString m_message; bool connectedToHost = false; QTcpSocket* socket; QString userName(); QString messages(); QString message(); void setUserName(const QString &amp;userName); void setMessages(const QString &amp;messages); void setMessage(const QString &amp;message); void printMessage(QString message);public: explicit ClientConnection(QObject *parent = nullptr);public slots: void on_connectButton_clicked(); void on_sendButton_clicked(); void socketConnected(); void socketDisconnected(); void socketReadyRead(); bool isConnectedToHost();signals: void userNameChanged(); void messagesChanged(); void isConnectedChanged(); void messageChanged();};#endif // CLIENTCONNECTION_H This is the source code of TCP client implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &quot;clientconnection.h&quot;ClientConnection::ClientConnection(QObject *parent) : QObject{parent}{}QString ClientConnection::userName(){ return m_userName;}QString ClientConnection::messages(){ return m_messages;}QString ClientConnection::message(){ return m_message;}void ClientConnection::setUserName(const QString &amp;userName){ if (userName == m_userName) return; m_userName = userName; emit userNameChanged();}void ClientConnection::setMessages(const QString &amp;messages){ m_messages = messages; emit messagesChanged();}void ClientConnection::setMessage(const QString &amp;message){ m_message = message; emit messageChanged();}void ClientConnection::on_connectButton_clicked(){ if (!connectedToHost) { socket = new QTcpSocket(); connect(socket, &amp;QTcpSocket::connected, this, &amp;ClientConnection::socketConnected); connect(socket, &amp;QTcpSocket::disconnected, this, &amp;ClientConnection::socketDisconnected); connect(socket, &amp;QTcpSocket::readyRead, this, &amp;ClientConnection::socketReadyRead); socket-&gt;connectToHost(&quot;127.0.0.1&quot;, 8001); } else { socket-&gt;write(&quot;&lt;font color=\\&quot;Orange\\&quot;&gt;&quot; + m_userName.toUtf8() + &quot; has left the chat room.&lt;/font&gt;&lt;br&gt;&quot;); socket-&gt;disconnectFromHost(); delete socket; }}void ClientConnection::on_sendButton_clicked(){ socket-&gt;write(&quot;&lt;br&gt;&lt;font color=\\&quot;Blue\\&quot;&gt;&quot; + m_userName.toUtf8() + &quot;&lt;/font&gt;: &quot; + m_message.toUtf8());}void ClientConnection::socketConnected(){ qDebug() &lt;&lt; &quot;Connected to server.&quot;; printMessage(&quot;&lt;font color=\\&quot;Green\\&quot;&gt;Connected to server.&lt;/font&gt;&quot;); socket-&gt;write(&quot;&lt;br&gt;&lt;font color=\\&quot;Purple\\&quot;&gt;&quot; + m_userName.toUtf8() + &quot; has joined the chat room.&lt;/font&gt;&quot;); connectedToHost = true; emit isConnectedChanged();}void ClientConnection::socketDisconnected(){ qDebug() &lt;&lt; &quot;Disconnected from server.&quot;; printMessage(&quot;&lt;br&gt;&lt;font color=\\&quot;Red\\&quot;&gt;Disconnected from server.&lt;/font&gt;&lt;br&gt;&quot;); connectedToHost = false; emit isConnectedChanged();}void ClientConnection::socketReadyRead(){ printMessage(socket-&gt;readAll());}void ClientConnection::printMessage(QString message){ m_messages.append(message); emit messagesChanged();}bool ClientConnection::isConnectedToHost(){ return connectedToHost;} This is the QML file to build the UI of the TCP client immplementation. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import QtQuick 2.0import QtQuick.Controls 2.0import QtQuick.Layoutsimport QtQuick.Controls.Universalimport QML_Client 1.0Window { id: window width: 640 height: 480 visible: true title: qsTr(&quot;Client Window&quot;) color: &quot;mediumseagreen&quot; ClientConnection { id: clientConnection } ColumnLayout { id: infoColumn anchors { left: parent.left right: parent.right top: parent.top bottom: parent.bottom margins: 16 } RowLayout { id: userRow height: 40 width: infoColumn.width Text { id: nameLabel text: qsTr(&quot;Name:&quot;) font.pointSize: 15 color: &quot;white&quot; font.weight: Font.Medium } TextField { id: textFieldName Layout.fillWidth: true onTextChanged: clientConnection.userName = text placeholderText: qsTr(&quot;Input your name&quot;) readOnly: clientConnection.isConnected background: Rectangle { implicitHeight: 30 anchors.fill: parent height: 120 color: &quot;white&quot; border.color: textFieldName.activeFocus ? &quot;greenyellow&quot; : &quot;lightslategrey&quot; border.width: 3 radius: 5 } } Button { id: connectButton text: clientConnection.isConnected ? &quot;Disconnect&quot; : &quot;Connect&quot; Layout.alignment: Qt.AlignRight palette.buttonText: &quot;white&quot; enabled: { if(textFieldName.text === &quot;&quot;) { false } else { true } } onClicked: { clientConnection.on_connectButton_clicked() forceActiveFocus() } contentItem: Text { text: connectButton.text font.weight: Font.Medium color: &quot;white&quot; horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter elide: Text.ElideRight } } } ScrollView { Layout.fillWidth: true Layout.fillHeight: true ScrollBar.vertical.policy: ScrollBar.AlwaysOff TextArea { id: textArea wrapMode: TextArea.Wrap text: clientConnection.messages textFormat: Text.RichText readOnly: true selectionColor: &quot;green&quot; background: Rectangle { color: &quot;white&quot; border.color: &quot;springgreen&quot; border.width: 3 radius: 5 } } } RowLayout { TextField { id: messageTextField Layout.fillWidth: true //text: clientConnection.message placeholderText: qsTr(&quot;Input your message&quot;) onTextChanged: clientConnection.message = text; background: Rectangle { implicitHeight: 30 color: &quot;white&quot; border.color: messageTextField.activeFocus ? &quot;greenyellow&quot; : &quot;lightslategrey&quot; border.width: 3 radius: 5 } } Button { id: sendButton text: &quot;Send&quot; Layout.alignment: Qt.AlignRight contentItem: Text { text: sendButton.text font.weight: Font.Medium color: &quot;white&quot; horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter elide: Text.ElideRight } onClicked: { clientConnection.on_sendButton_clicked() messageTextField.clear(); forceActiveFocus() } enabled: { if(messageTextField.text === &quot;&quot; || textFieldName.text === &quot;&quot; || !clientConnection.isConnected) { false } else { true } } } } }}","link":"/kelvin-blog/2024/12/09/TCP-Socket-Communication-using-C-and-Qt-6/"}],"tags":[{"name":"QML","slug":"QML","link":"/kelvin-blog/tags/QML/"},{"name":"TabBar","slug":"TabBar","link":"/kelvin-blog/tags/TabBar/"},{"name":"TabButton","slug":"TabButton","link":"/kelvin-blog/tags/TabButton/"},{"name":"Qt 6","slug":"Qt-6","link":"/kelvin-blog/tags/Qt-6/"},{"name":"C++","slug":"C","link":"/kelvin-blog/tags/C/"},{"name":"StackView","slug":"StackView","link":"/kelvin-blog/tags/StackView/"},{"name":"TCP Server","slug":"TCP-Server","link":"/kelvin-blog/tags/TCP-Server/"},{"name":"TCP Client","slug":"TCP-Client","link":"/kelvin-blog/tags/TCP-Client/"}],"categories":[],"pages":[]}